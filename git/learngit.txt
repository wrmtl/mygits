git config --global user.email ""
git config --global user.name ""

git init
git add <path/filename>
git commit -m "注释"

git status 只能查看缓冲区内哪些文件发生了变化，若其中没有文件发生变化，就无法查看缓冲区内有哪些文件（哪些文件曾被 add 过）

你可以使用 git ls-files 查看缓冲区内有哪些文件

git log		查看仓库日志   commit ID    提交人和邮箱    提交备注
git reset --hard HEAD~n		还原会以前第n各版本
git reset --hard commit id	还原提交号的状态（只需要前几位即可，支持搜索）
git diff HEAD -- readme.txt	可以查看工作区和版本库里面最新版本的区别：

回退快速，指针还原，然后顺便把工作区的文件更新


git reflog	查找所有操作的commit id


工作区（Working Directory）

版本库（Repository）	.git隐藏文件

stage（index）暂存区	master分支

LICENSE还从来没有被添加过，所以它的状态是Untracked。
把提交的修改git add进入缓存区，git commit提交到分支


工作区―git add―缓存区―git commit―版本库





git checkout -- filename	把filename文件在工作区的修改全部撤销

一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库或暂存区一模一样的状态；
一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。
且该撤销只撤销回其修改前，最近一次add或commit的状态，，和当前index中的状态并无一定连接关系





git reset HEAD file可以把暂存区的修改撤销掉（unstage），用最新版本库更新暂存库，并不影响工作区状态





通常直接在文件管理器中把没用的文件删了，或者用rm命令删了：

$ rm test.txt

这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了：

现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit：

$ git rm test.txt
rm 'test.txt'
$ git commit -m "remove test.txt"

另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：

$ git checkout -- test.txt

git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。